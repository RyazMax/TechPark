// Автор Рязанов Максим АПО-13
/*
Условие:
Даны неотрицательные целые числа n, k и массив целых чисел из диапазона [0..109]
размера n. Требуется найти k-ю порядковую статистику. т.е. напечатать число,
которое бы стояло на позиции с индексом k ∈[0..n-1] в отсортированном массиве.
Напишите нерекурсивный алгоритм.
Требования к дополнительной памяти: O(n).
Требуемое среднее время работы: O(n).

Функцию Partition следует реализовывать методом прохода двумя итераторами в 
одном направлении.
Описание для случая прохода от начала массива к концу:
Выбирается опорный элемент.
Опорный элемент меняется с последним элементом массива.
Во время работы Partition в начале массива содержатся элементы, не бОльшие опорного. 
Затем располагаются элементы, строго бОльшие опорного. В конце массива лежат 
нерассмотренные элементы. Последним элементом лежит опорный.
Итератор (индекс) i указывает на начало группы элементов, строго бОльших опорного.
Итератор j больше i, итератор j указывает на первый нерассмотренный элемент.
Шаг алгоритма. Рассматривается элемент, на который указывает j. 
Если он больше опорного, то сдвигаем j. Если он не больше опорного, 
то меняем a[i] и a[j] местами, сдвигаем i и сдвигаем j.
В конце работы алгоритма меняем опорный и элемент, на который указывает итератор i. 

Реализуйте стратегию выбора опорного элемента “случайный элемент”. Функцию Partition 
реализуйте методом прохода двумя итераторами от конца массива к началу.
*/

#include <iostream>
#include <ctime>

// Стандартный функтор "меньше"
template <class T>
bool isLessDefault(const T& left, const T& right)
{
    return left<right;
}

// Разделеение элементов массива относительно выбранного pivot
// Выбор pivot случайный
template <class T, class Compare>
int partition(T* arr, int left, int right, const Compare& functor)
{
    int pivot = rand()%(right-left) + left;
    std::swap(arr[pivot], arr[left]);
    // Указатель на первый элемент меньший выбранного
    int i = right-1;
    // Указатель на первый непроверенный элемент
    int j = right-1;

    while (j > left) {
        if (functor(arr[j], arr[left])) {
            --j;
        } else {
            std::swap(arr[i--], arr[j--]);
        }
    }

    std::swap(arr[left], arr[i]);
    return i;
}

// Вычисление порядковой статистики pos
template <class T, class Compare>
int orderStatistic(T* arr, int size, int pos, const Compare& functor)
{
    int pivot = 0; // Выбранный элемент
    int left = 0; // Левая граница диапозона
    int right = size; // Правая граница диапозона
    do {
        pivot = partition(arr, left, right, functor);
        if (pivot > pos) {
            right = pivot;
        } else {
            left = pivot + 1;
        }
    } while (pivot != pos);

    return pivot;
}

int main()
{
    srand(time(0));
    int size = 0; // Размер массива
    int pos = 0; // Номер порядковой статистики

    std::cin>>size;
    std::cin>>pos;

    int* arr = new int[size]; // Массив

    for (int i = 0; i<size; ++i) {
        std::cin>>arr[i];
    }

    pos = orderStatistic(arr, size, pos, isLessDefault<int>);
    std::cout<<arr[pos];

    delete[] arr;
    return 0;
}